3. Предложите алгоритм для удаления дубликатов (или выбора уникальных элементов) из вектора.
Оцените временную и пространственную сложность.

Алгоритм для удаления дубликатов
Описание:
    Проход вектора от начала к концу.
    Для каждого элемента в векторе ищутся дубликаты в диапазоне от следующего элемента до последнего.
    Если дубликат найден, то его удаляют из вектора. Удаленные дубликаты не учавствуют больше в поиске.

    Временная сложность: Квадратичная.
    В худшем случае: O(n^2). Отсутствуют дубликаты, проход всех n-1 элементов, сравнение i-го 
        элемента с каждым в диапазоне i+1 до n, где n - длина вектора.
        i=0;i<n-1;i++
        (n-1)+(n-2)+...+(1) = n^2/2. O(n^2/2)==O(n^2)
    Пространственная сложность: Линейная.
    В худшем случае: O(n). Используется только память для вектора,  отдельные переменные, массивы 
        и т.п. не создаются.

Код на С++:
    template<class T>
    void removeDuplicates(std::vector<T> v){
        for (std::vector<T>::iterator i = v.begin() ; i != v.end()-1; ++i)
            //erase-remove idiom
            v.erase( std::remove( i+1, v.end(), *i ), v.end() ); //Удаление всех дубликатов
    }
